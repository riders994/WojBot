from collections import defaultdict
import numpy as np
from numpy import AxisError

"""
Common functions that could be used amongst different Cogs
"""


def create_flag_dict(messages):
    """
    Digests a message, and produces a dictionary of all flags and the args associated with them.
    :param messages: str. A string of flags and args.
                          * '-' flags signal string arguments that denote user input
                          * '+' flags signal boolean arguments
    :return: dict. Dictionary of flags and args
    ex: Input: '-w 1:20, +o'
        Output: {'w': [1:20], 'o': [True]}
    """
    res = defaultdict(list)
    is_flagged = None
    for i, msg in enumerate(messages.split(' ')):
        if msg[0] == '-':
            flag = msg.strip('-')
            is_flagged = i + 1
        if i == is_flagged:
            res[flag].append(msg)
        if msg[0] == '+':
            res[msg.replace('+', '')].append(True)

    return res


def get_flag(flag, flag_map, flag_dict):
    """
    Returns the flags associated with the specific mapping for this user for the specified flag.
    :param flag: str. Should be name of a type of flag, and be a key in the map.
    :param flag_map: dict. This should come from the upper level bot. A mapping of different options for flag names that
                           league players can use for each command. This allows commands to have overlapping flags
                           without hurting functionality between them.
    :param flag_dict: dict. Dict generated by create_flag_dict.
    :return: Args. Depends on how content was generated.
    """
    for check in flag_map[flag]:
        res = flag_dict.get(check)
        if res:
            return res[0]


def parse_dice(command):
    pieces = command.split(' ')
    roll = pieces[0]
    rpieces = roll.split('d')
    res_messages = list()
    try:
        res = np.random.randint(1, int(rpieces[1]) + 1, int(rpieces[0]))
    except ValueError:
        res = np.random.randint(1, 21)
    if len(pieces) - 1:
        mods = set(pieces[1:])
        if 'adv' in mods:
            adv = np.random.randint(1, int(rpieces[1]) + 1, int(rpieces[0]))
            m = """\nwith advantage"""
            finalres = res.sum()
            res = np.amax(np.array([res, adv]), axis=0)
            if '+' in mods:
                finalres += int(pieces[pieces.index('+') + 1])
            for i in range(adv.shape[0]):
                m += ' {}'
            m += '\n' + ' ' * (12 + len(str(finalres)))
            for i in range(adv.shape[0]):
                m += ' {}'
            if not adv.shape[0] - 1:
                res = np.array((res,))
            try:
                new = m.format(np.concatenate((res, adv), axis=1))
            except AxisError:
                t = np.concatenate((res, adv))
                new = m.format(*list(t))
            res_messages.append(new)
        if 'dis' in mods:
            dis = np.random.randint(1, int(rpieces[1]) + 1, int(rpieces[0]))
            m = """\nwith disadvantage"""
            finalres = res.sum()
            res = np.amin(np.array([res, dis]), axis=0)
            for i in range(dis.shape[0]):
                m += ' {}'
            m += '\n' + ' ' * (14 + len(str(finalres)))
            for i in range(dis.shape[0]):
                m += ' {}'
            if not dis.shape[0] - 1:
                res = np.array((res,))
            try:
                new = m.format(np.concatenate((res, dis), axis=1))
            except AxisError:
                t = np.concatenate((res, dis))
                new = m.format(*list(t))
            res_messages.append(new)
        finalres = res.sum()
        if '+' in mods:
            finalres += int(pieces[pieces.index('+') + 1])
            res_messages.append('\nand a modifier of {}'.format(int(pieces[pieces.index('+') + 1])))
    else:
        finalres = res.sum()
    dice = ', '.join([str(i) for i in list(res)])
    message = """You rolled a {}!

These were your dice: {}""".format(finalres, dice)
    modmessage = ""
    for v in res_messages:
        modmessage += v
    if len(modmessage):
        message += modmessage
    return message + '.'
